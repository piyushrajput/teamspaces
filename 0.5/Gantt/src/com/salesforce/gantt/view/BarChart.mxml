<mx:Panel
	 xmlns:mx = "http://www.adobe.com/2006/mxml" styleName="barChartMainPanel"  
	 horizontalScrollPolicy="off" verticalScrollPolicy="off" verticalGap="0" horizontalGap="0"
	 dropShadowEnabled="false" 
	   borderThickness="0">
<mx:Script>
	<![CDATA[
		import mx.skins.Border;
		import mx.controls.TextInput;
		import mx.core.SpriteAsset;
		import com.salesforce.gantt.model.Dependency;
		import mx.controls.Text;
		import com.salesforce.gantt.model.GanttState;
		import com.salesforce.gantt.model.Calendar;
		import com.salesforce.gantt.controller.Constants;
		import com.salesforce.gantt.renderers.TaskRenderer;
		import com.salesforce.Connection;
	    import mx.controls.scrollClasses.ScrollBar;	
	    import com.salesforce.gantt.view.components.DragHorizontal;
	    import mx.containers.Panel; 	
	    import com.salesforce.gantt.model.UI;
	    import com.salesforce.gantt.model.UiTask;
	    import com.salesforce.gantt.model.Task;
	    import com.salesforce.gantt.model.TaskDate;
	    import com.salesforce.gantt.model.User;
	    import com.salesforce.gantt.controller.Components;	
    	import mx.collections.ArrayCollection;
    	import mx.events.ListEvent; 	
    	import flash.events.TimerEvent;
        import flash.utils.Timer;
        import mx.managers.DragManager;
 	    import mx.core.DragSource;
   	    import mx.events.DragEvent;
   	    import mx.containers.Canvas;
   	    import mx.events.SliderEvent;
        import mx.controls.sliderClasses.Slider;
   	    import mx.utils.GraphicsUtil;
   	    
   	    import flash.ui.Mouse;
		import mx.collections.IViewCursor;
		import mx.managers.CursorManager;
	
   	    import mx.printing.*;
    	import com.salesforce.gantt.view.print.FormPrintViewBarChart;
    
	    //[Bindable]
        //public var tasks : ArrayCollection;
        [Bindable]
        public var selectedTask : UiTask;
        [Bindable]
        public var rangeDates : ArrayCollection = new ArrayCollection();
        public var rangeDatesAll : ArrayCollection = new ArrayCollection();
        
        private var xOffsetDrag : Number = 0;
	    private var yOffsetDrag : Number = 0;
	    private var timer : Timer;
     	private var direction : String;//Leindica al timer el sentido en que se debe mover el panel
       
        public var hasDeleteLastTask : Boolean = false;
       
       	[Bindable]
    	private var isLabelVisible : Boolean = true;
    	private var calendarScale : int = 1;
    	
	    public var zoom : int = 30;
    	
    	[Embed(source="../view/imgs/hand_up.png")]
	    private var cursorHandUp : Class;
	    
	    [Embed(source="../view/imgs/hand_down.png")]
	    private var cursorHandDown : Class;
	    
	    [Embed(source="../view/imgs/resize_cursor.png")]
	    private var cursorLeftUp : Class;
	    
	    [Embed(source="../view/imgs/resize_cursor.png")]
	    private var cursorRightUp : Class;
	    
	    [Embed(source="../view/imgs/move_cursor.png")]
	    private var cursorCenterUp : Class;
	    
	    [Embed(source="../view/imgs/resize_cursor.png")] 
	    private var cursorLeftDown : Class;
	    
	    [Embed(source="../view/imgs/resize_cursor.png")]
	    private var cursorRightDown : Class;
	    
	    [Embed(source="../view/imgs/move_cursor.png")]
	    private var cursorCenterDown : Class;
    
    	[Embed(source="../view/imgs/lin.gif")]
	    private var linScale : Class;
	    
	
        public function selectTask(taskId : String) : void
	    {
		  	Components.instance.tasks.select(taskId);		  	
		  	//dispatchEvent(new Event(Constants.TASK_SELECT));
		  	parentDocument.selectTask();
		  	
	    }
	    
	    //public var taskDeleted : Task;
	    public function setTasksDeleted(task : Task) : void
	    {
	    	//si se esta borrando la ultima tarea
	    	if(Components.instance.tasks.allTasks.length==1)
	    	{
	    		hasDeleteLastTask = true;
	    		parentDocument.taskList.filter();
	    		var taskTemp : Task = UiTask(task).clone();
				parentDocument.editTaskPanel.clearSelectedTask();
				clesrBorderSelected();
				Components.instance.controller.deleteTask(taskTemp);
				initTimerRefresh();
	    	}
	    	else
	    	{
		    	var taskTemp : Task = UiTask(task).clone();
				parentDocument.editTaskPanel.clearSelectedTask();
				clesrBorderSelected();
				Components.instance.controller.deleteTask(taskTemp);
				Components.instance.tasks.setParent();
				dispatchEvent(new Event(Constants.TASKS_FILTERS));
	    	}
	  		//initTimer(taskTemp);
	    }
	    private var timerRefresh : Timer;
	    public function initTimerRefresh() : void 
	    {
	        timerRefresh = new Timer(100, 1);
	        timerRefresh.addEventListener(TimerEvent.TIMER, dispatchTimerRefresh);
	        timerRefresh.addEventListener(TimerEvent.TIMER_COMPLETE, completeTimerRefresh);
	        timerRefresh.start();
	    }
	    public function dispatchTimerRefresh(event : TimerEvent) : void
		{
			dispatchEvent(new Event(Constants.TASKS_FILTERS));
		}
	    public function completeTimerRefresh(event : TimerEvent):void
	    {
	    	timerRefresh.stop();
	    	hasDeleteLastTask = false;
	    }
	    
	    
	    public function centerToday(): void
	    {

	   		moveBarChartHorizontally(600);
	    }
	  
	  
	
	    /*
	     * Mueve las flechas que se encuanrtran sobrelas barras (up, down, left, right)
	     */
	    public function moveArrows() : void
	    {	
	    	var moveForRotation : int = 25;
	    	
		  var height : int = parentDocument.dragPanelTasks.height - 50;
		  var left : int = parentDocument.dragPanelTasks.width - barChartCanvas.x;
		  var right : int =  parentApplication.width - parentDocument.editPanel.width - barChartCanvas.x;
		  var arrowSize : int = leftArrow.width;
		
	   	  leftArrow.x = left;
		  rightArrow.x = right - arrowSize - 10 + moveForRotation;
	 	  var xCenter : int = leftArrow.x + ((rightArrow.x - leftArrow.x) /2);
		  upArrow.x = xCenter;
		  downArrow.x = xCenter + moveForRotation;
		
		  leftArrow.y = (height / 2) - (barChartCanvas.y) + moveForRotation;
		  rightArrow.y = (height / 2) - (barChartCanvas.y);
		  upArrow.y = 20 - (barChartCanvas.y);   
		  downArrow.y = (height - 20) - (barChartCanvas.y) + moveForRotation;
		  
		  //showOverview.x = right - (arrowSize - 5);
		  //showOverview.y = (height) - (barChartCanvas.y) + 2;
		  
		  labelVisibleMonth.x = left;
		  labelVisibleMonth.y = (height - 20) - (barChartCanvas.y);
	    } 
		/**
		 * Es llamado por cada dia que esta en la escala
		 * para que se le cambie el estilo dependiento si
		 * el dia es entre semana o fin de semana
		 */
	   private function getBackgroundStyle(date : Date) : String
	   {   
	   		var backgroundStyleName : String = "weekDayLabel";
	   		if(calendarScale == 1)
	   		{  
			  //si es sabado o domingo
			  if(date.getDay() == 0 || date.getDay() == 6)
			  {
				backgroundStyleName = "weekendLabel";
			  }
	   		}
		  return backgroundStyleName;
	   }
		/*
		 * Es llamado por cada dia que esta en la escala
		 * para que se le cambie el color de fondo dependiento si
		 * el dia es entre semana o fin de semana
		 */
	   private function getOpaqueBackground(date : Date) : String
	   {
		  var color : String = "0xFFFFFF";
		  if(calendarScale == 1)
	   	  { 
			  //si es sabado y domingo
			  if(date.getDay() == 0 || date.getDay() == 6)
			  {
				color = "0xEAEAEA";
			  }
	   	  }
		  return color;
	   }
	   /*
	    * Centra la tarea seleccionada en la parte visible de la ventana
	    */
	   public function centerSelected(panelTasksWidth : int, editPanelWidth : int, editPanelX : int) : void
	   {
			var task : Task = Components.instance.tasks.selectedTask.clone();
			var windowWidth : int = parentApplication.width;
			if(windowWidth > (panelTasksWidth + editPanelWidth))
			{
				var x : Number = task.startDate.toDay() * UI.scale;
				var taskWidth : Number = task.duration * UI.scale;
				
				var panelXStart : int = panelTasksWidth;
				var panelXEnd : int = panelTasksWidth + ( editPanelX - panelTasksWidth );
				
				var mediumPosition : int = panelXStart + ((panelXEnd - panelXStart) / 2 - (taskWidth / 2)); 
				if((mediumPosition - x) < 0)
				{
					datesCanvas.x = mediumPosition - x;
					barChartCanvas.x = mediumPosition - x;
				}
				else
				{
					datesCanvas.x = 0;
					barChartCanvas.x = 0;
				}
			}
		}
		/*
		* Retorna la posicion x para restar en el caso de que se este imprimiendo
		* para que comienze en 0, en caso de que no este imprimiendo no se debe restar nada
		*/
		public function startValueReduce( date : Date ) : int
	    {
	    	var firstTask : Task = Components.instance.tasks.firstTask();
	    	if(this.parentApplication.mainView.barChart.hasPrinting)
	    	{
	    		return (-Components.instance.calendar.toDay(firstTask.startDate.date))
	    	}
	    	else
	    	{
	    		return 0;
	    	}
	    }
		/*
		 * Retorna el tamanio de la escala equivalente a un dia
		 */
        public function getScale() : Number
		{
			if(!hasPrinting)
			{
				return UI.scale;
				//var firstTask : Task = Components.instance.tasks.firstTask();
				//return (750 / (Components.instance.calendar.toDay(TaskDate.endDate) - Components.instance.calendar.toDay(firstTask.startDate.date)));
			}
			else
			{
				var firstTask : Task = Components.instance.tasks.firstTask();
				return ((pageWidthPrinting - 80) / (Components.instance.calendar.toDay(TaskDate.endDate) - Components.instance.calendar.toDay(firstTask.startDate.date)));
			}
		}
		public var hasPrinting : Boolean = false;
		public var pageWidthPrinting : int = 0;
		/*
		* The function to print the output.
		*/
	    public function doPrint():void 
	    {
	    	hasPrinting = true;
	    	var scaleRowHeightPrint : int = 30;
	        var printJob : FlexPrintJob = new FlexPrintJob();
	        if (printJob.start()) {
	            // Create a FormPrintView control as a child of the current view.
	            var thePrintView : FormPrintViewBarChart = new FormPrintViewBarChart();
	            
	            parentApplication.addChild(thePrintView);
	            
	            pageWidthPrinting=printJob.pageWidth;
	            
	            //Set the print view properties.
	            thePrintView.width	= printJob.pageWidth + 10;
	            thePrintView.height	= printJob.pageHeight + 30;
	            
	            thePrintView.myDataGrid.rowHeight 		= scaleRowHeightPrint;//seteo el rowHeight
	            thePrintView.myDataGrid.dataProvider 	= bars.dataProvider;//seteo el dataprovider task
	           	thePrintView.myDataGridDates.rowHeight 		= 1;//seteo el rowHeight
	           	thePrintView.myDataGridDates.dataProvider 	= getDatesPrint();//seteo el dataprovider dates

				//  thePrintView.prodTotal = prodTotal;
	            // Create a single-page image.
	            thePrintView.showPage("single");
	            // If the print image's data grid can hold all the provider's rows, 
	            // add the page to the print job. 
	            if(!thePrintView.myDataGrid.validNextPage)
	            {
	                printJob.addObject(thePrintView);
	            }
	            // Otherwise, the job requires multiple pages.
	            else
	            {
	                // Create the first page and add it to the print job.
	                thePrintView.showPage("first");
	                printJob.addObject(thePrintView);
	                thePrintView.pageNumber++;
	                // Loop through the following code until all pages are queued.
	                while(true)
	                {
	                    // Move the next page of data to the top of the print grid.
	                    thePrintView.myDataGrid.nextPage();
	                    thePrintView.showPage("last");    
	                    // If the page holds the remaining data, or if the last page 
	                    // was completely filled by the last grid data, queue it for printing.
	                    // Test if there is data for another PrintDataGrid page.
	                    if(!thePrintView.myDataGrid.validNextPage) 
	                    {
	                        // This is the last page; queue it and exit the print loop.
	                        printJob.addObject(thePrintView);
	                        break;
	                    }
	                    else
	                    // This is not the last page. Queue a middle page. 
	                    {
	                        thePrintView.showPage("middle");
	                        printJob.addObject(thePrintView);
	                        thePrintView.pageNumber++;
	                    }
	                }
	            }
	            // All pages are queued; remove the FormPrintView control to free memory.
	            parentApplication.removeChild(thePrintView);
	        }
	        // Send the job to the printer.
	        printJob.send();
	        hasPrinting=false;
	    }
		public var datesScale : ArrayCollection = new ArrayCollection();
		public function getDatesPrintPosition(date : Date) : int
		{
			for(var i : int = 0; i < datesScale.length; i++)
			{
				if(datesScale.getItemAt(i).getTime()==date.getTime())
				{
					return i;
				}
			}
			return -1;
		}
		/*
		* Retorna true si la resta entre la primer y la ultima tarea es mas de un mes
		*/
		public function isMoreOfAMonth() : Boolean
		{
			var firstTask : Task = Components.instance.tasks.firstTask();
			return ((Components.instance.calendar.toDay(TaskDate.endDate) - Components.instance.calendar.toDay(firstTask.startDate.date)) > 31);
		}
		/*
		* Retorna una coleccion con las fechas de la escala del gantt de impresion
		*/
		private function getDatesPrint() : ArrayCollection
	    {
	    	datesScale = new ArrayCollection();
			var endDateView : int = Components.instance.calendar.toDay(TaskDate.endDate);
			var firstTask : Task = Components.instance.tasks.firstTask();
			var isMoreOfAMonth : Boolean = isMoreOfAMonth();
			for(var i : int = 0; i < endDateView; i++)
			{
				var tempDate : Date = Components.instance.calendar.add(firstTask.startDate.date, i)
				if(isMoreOfAMonth)
				{
					if(tempDate.getDate() == 1)
					{
						if(tempDate.hours == 23)
						{
							tempDate = Components.instance.calendar.addHours(tempDate,-23);
						}
						datesScale.addItem(tempDate);	
					}
				}
				else
				{
					if(tempDate.hours == 23)
					{
						tempDate = Components.instance.calendar.addHours(tempDate,-23);
					}
					datesScale.addItem(tempDate);
				}
			}
			return datesScale;
	    }
		/*
		 * Mueve las barras horizontalmente
		 * El parametro move es la cantiad de pixeles que se mueven
		 */
	   public function moveBarChartHorizontally(move : int) : void
	   {
	   	  var x : int = datesCanvas.x + move;
	   	  if(-x < lastTaskX())
	   	  {	
			  if (x <= 0)
			  {	
				datesCanvas.x = x;
				barChartCanvas.x = x;
			  }
			  else
			  {
				datesCanvas.x = 0;
				barChartCanvas.x = 0;
			  }
		  }
	   }
	   /*
		* Retorna el valor x maximo hasta donde se puede hacer drag
		*/
	   public function lastTaskX() : Number
	   {
	   		return ((Components.instance.calendar.toDay(TaskDate.endDate)) * UI.scale) - 940;
	   }
	   /*
		 * Mueve las barras verticalmente
		 * El parametro move es la cantiad de pixeles que se mueven
		 */
	   public function moveBarChartVertically(move : int) : void
	   {
	   	  if(parentDocument.taskList.visibleTasks!=null)
	   	  {
			  if ((barChartCanvas.y + move) < 0)
			  {
			  	  var maxY : int = ((parentDocument.taskList.visibleTasks.length + 2) * UI.ROW_HEIGHT) - mainCanvas.height;
			  	  if(-(barChartCanvas.y + move) > maxY)
			   	  {
			   	  	if(-maxY < 0)
			   	  	{
			   	  		barChartCanvas.y = - maxY;// - (maxY + (2 * UI.ROW_HEIGHT));
			   	  	}
			   	  	else
			   	  	{
			   	  		barChartCanvas.y = 0;
			   	  	}
			   	  }
			   	  else
			   	  {
					barChartCanvas.y = barChartCanvas.y + move;
			   	  }
			   	  //parentDocument.taskList.moveGrid(bars.rowHeight, - barChartCanvas.y);
			  }
			  else
			  {
				barChartCanvas.y = 0;
				parentDocument.taskList.moveGrid(bars.rowHeight, 0);
			  }
			  //parentDocument.barChartOverview.setMaskProperties();
			  //moveArrows();
	   	  }
	   }
	   
	   public var isDraging : Boolean = false;
	   public var isMouseDown : Boolean = false;
	   public var taskIdClicked : String = '';
	   public var taskClicked : Task = null;
	   private var moveSelect : String = '';
	   /*
	    * Llamada cuando se mueve una tarea para indicarle al barChart
	    * cual es la tarea que se esta moviendo e indicarle el sentido del movimiento
	    */
	   public function dragAndDropBar(taskId : String, moveSelect : String) : void
	   {
	   	 
			   	
	   		this.moveSelect = moveSelect;
	   		taskIdClicked = taskId;
	   	
	   		if(taskIdClicked!='')
	   		{
	   			
		   			taskClicked = Components.instance.tasks.getTask(taskIdClicked).clone();
		   			
		   			var taskVisible : Task = parentDocument.taskList.getVisibleTask(taskClicked.id);
		   	   		var taskTemp : Task = UiTask(taskClicked).clone();
		   	   		taskTemp.positionVisible = taskVisible.positionVisible;
		   	   	
		   	   		paintSelect(taskTemp);
		   	 	
		   	}
	   		else
	   		{
	   			taskClicked = null;
	   		}
	   	 
	   	
	   }
	   /*
		* Marca el borde de una tarea seleccionada
		*/
	   public function paintSelect(task : Task) : void
	   {
	   		if(task!=null)
	   		{
		   		drawBorderSelected(task);
		   		parentDocument.taskList.setPaintIndices(task.positionVisible-1);
				parentDocument.taskList.drawSpriteCell();
	   		}
	   }
	   /*
	    * Inicializa el evento drag and drop
	    */
   	   private function panelHandler(event : Event) : void
       {
  		  barChartCanvas.addEventListener(MouseEvent.MOUSE_DOWN, mouseMoveHandler);
  		  barChartCanvas.addEventListener(MouseEvent.MOUSE_UP, clickHandler);
  		  // barChartCanvas.addEventListener(MouseEvent.DOUBLE_CLICK,doubleClickHandler); 
   	   }
   	   /*
	    * Si se esta haciendo drag and drop sobre una tarea, esta se mueve
	    */
   	   private function moveHandler(event : MouseEvent) : void
   	   {
   	   		//Aqui entra al momento de dragar o estirar la tarea			
   	   		isMouseDown = false;
   	   		//si hay una tarea seleccionada se mueve, agranda o achica la tarea 
   	   		if(taskIdClicked != '' && (parentDocument.canModifySelectedTask || parentDocument.userProfilePermissions.canManage))
   	   		{
   	   			//trace('Dragging!');
   	   			Components.instance.tasks.select(taskIdClicked);
   	   			taskClicked = Components.instance.tasks.getTask(taskIdClicked).clone();
   	   			var mouseY : int = int((event.stageY - barChartCanvas.y - 30) / UI.ROW_HEIGHT);
   	   			
   	   			//si el eje y es el de la tarea que se esta haciendo el drag
   	   			if(mouseY == taskClicked.positionVisible || moveSelect!='center')
	   	   		{
	   	   			var scale : Number = getScale();
		   	   		var taskX : Number = taskClicked.startDate.toDay() * scale;
		   	   		var defasaje : Number = 0.30;
		   	   		var y : int = (taskClicked.positionVisible * 30) - 25;
		   	   		var x : Number = 0;
		   	   		var move : Number = 0;
		   	   		switch(moveSelect)
		   	   		{
		   	   			case 'center'://se arrastra del centro (se mueve la tarea)
		   	   			
		   	   				var positionInpixels : Number = ((event.stageX - barChartCanvas.x) - taskX);
		   	   				move = (positionInpixels / UI.scale);
		   	   				if(positionInpixels<0)
		   	   				{
		   	   					move--;
		   	   				}

		   	   				move=Math.round(move);
			   	   			if(move!=0)
			   	   			{
			   	   				
			   	   				taskClicked.startDate.date.setTime(taskClicked.startDate.date.getTime() + Components.instance.calendar.toMillis(move));
		   						taskClicked.endDate = new TaskDate(taskClicked.startDate.toString(Constants.DATABASE), taskClicked.duration );
		   						x = ((taskClicked.startDate.toDay() * scale)) + UI.MARGIN;
		   						
		   						/*trace((-barChartCanvas.x)+'+'+parentDocument.dragPanelTasks.width+'>'+x);
		   						if((-barChartCanvas.x)+parentDocument.dragPanelTasks.width>x)
		   						{
		   							moveBarChartHorizontally(60);
		   						}*/
		   						
		   						drawSpriteBar(event, taskClicked, x, y);
			   	   			}
		   	   				break;
		   	   			case 'right'://se arrastra de la derecha (se agranda o achica la tarea)
		   	   				var duration : int = (((event.stageX - barChartCanvas.x) - taskX) / scale) - defasaje + 1;
		   	   				
		   	   				if(duration > 0 && taskClicked.duration != duration)
		   	   				{
		   	   					taskClicked.duration = duration;
		   	   					taskClicked.endDate = new TaskDate(taskClicked.startDate.toString(Constants.DATABASE), taskClicked.duration );
		   	   					
		   	   					x = ((taskClicked.startDate.toDay() * scale)) + UI.MARGIN;
		   	   				
		   	   					drawSpriteBar(event, taskClicked, x, y);
		   	   				}
		   	   				break;
		   	   			case 'left'://se arrastra de la izquierda (se agranda o achica la tarea)
		   	   				if(((event.stageX - barChartCanvas.x) - taskX) > 10)//achica hacia derecha
		   	   				{
		   	   					move = (((event.stageX - barChartCanvas.x) - taskX) / UI.scale) - defasaje;
		   	   					if(taskClicked.duration > move && move > 0)
		   	   					{
		   	   						taskClicked.duration -= move;
		   	   						
		   	   						taskClicked.startDate.date.setTime(taskClicked.startDate.date.getTime() + Components.instance.calendar.toMillis(move));
		   	   						taskClicked.endDate = new TaskDate(taskClicked.startDate.toString(Constants.DATABASE), taskClicked.duration);
		   	   						
		   	   						x = ((taskClicked.startDate.toDay() * scale)) + UI.MARGIN;
		   	   						
		   	   						drawSpriteBar(event, taskClicked, x, y);
		   	   					}
		   	   				}
		   	   				else//agranda hacia izquierda
		   	   				{
		   	   					move = (((event.stageX - barChartCanvas.x) - taskX) / UI.scale) - defasaje - 1;
		   	   					move=Math.round(move);
		   	   					if(-move > 0)
		   	   					{
			   	   					taskClicked.duration -= move;
			   	   					taskClicked.startDate.date.setTime(taskClicked.startDate.date.getTime() + Components.instance.calendar.toMillis(move));
			   	   					taskClicked.endDate = new TaskDate(taskClicked.startDate.toString(Constants.DATABASE), taskClicked.duration);
			   	   					
			   	   					x = ((taskClicked.startDate.toDay() * scale)) + UI.MARGIN;
			   	   					
			   	   					drawSpriteBar(event, taskClicked, x, y);
			   	   				}
		   	   				}
		   	   				break;
		   	   		}
   	   			}
   	   			else//si la posicion Y no es el de la tarea sobre la que se hace el drag and drop
		   	   	{
		   	   		//se dibuja la tarea para ir mostrandolo a medida que se mueve el raton
		   	   		drawSpriteBar(event, taskClicked, -1, ((mouseY - 1) * UI.ROW_HEIGHT) + 2, false);
	   	   		}
	   	   	}
   	   }
   	   /*
		* Crea el Sprite object de la tarea seleccionada
		*/
   	   private function drawSpriteBar(event : MouseEvent, task : Task, x : Number = -1, y : Number = -1, hasText : Boolean = false) : void
   	   {
   	   		//se dibuja la tarea para ir mostrandolo a medida que se mueve el raton
   	   		var scale : Number = getScale();
   	   		//add 1 day for the duration to display task correctly 
   	   		var durationT : Number = (task.duration + 1);
	  		var width : Number = (durationT * scale);
			var height : Number = UI.ROW_HEIGHT - 8;
			if(x == -1)
			{
				x = -(barChartCanvas.x) + event.stageX;
			}
			if(y == -1)
			{
				y = event.stageY - 60 - barChartCanvas.y;
			}
			var name : String = 'name'+task.id;
			var size : int = 12;
			var hypotenuse : Number = size * 2;	
			var labelSprite : Sprite = Sprite(bars.getChildByName(name));
			var text : String = task.name;
			if(labelSprite == null)
			{
				labelSprite = new Sprite();
				labelSprite.name = name;
			}	
				var textFormat : TextFormat = null;
				var textFieldName : TextField = null;
				if(task.duration==0)
				{
					//var hypotenuse : Number = Math.sqrt((size * size) * 2);//pitagorian theoreen
					x = x + (scale / 2) - (hypotenuse / 2);
			
					labelSprite.x = x;
					labelSprite.y = y;
					
					labelSprite.graphics.clear();
					labelSprite.graphics.beginFill(Constants.COLOR_TASK_MILESTONE_FONT, 1);
					labelSprite.graphics.moveTo(0 + size, 0);
					labelSprite.graphics.lineTo(0 + size, 0);
					labelSprite.graphics.lineTo(0, 0 + size);
					labelSprite.graphics.lineTo(0 + size, 0 + (size * 2));
					labelSprite.graphics.lineTo(0 + (size * 2), 0 + size);
					
					labelSprite.graphics.endFill();
					
					labelSprite.graphics.lineStyle(2, Constants.COLOR_TASK_MILESTONE_BORDER_RIGHT, 1);
					labelSprite.graphics.moveTo(0 + size, 0);
					labelSprite.graphics.lineTo(0 + size, 0);
					labelSprite.graphics.lineStyle(2, Constants.COLOR_TASK_MILESTONE_BORDER_LEFT, 1);
					labelSprite.graphics.lineTo(0, 0 + size);
					labelSprite.graphics.lineTo(0 + size, 0 + (size * 2));
					labelSprite.graphics.lineStyle(2, Constants.COLOR_TASK_MILESTONE_BORDER_RIGHT, 1);
					labelSprite.graphics.lineTo(0 + (size * 2), 0 + size);
					labelSprite.graphics.lineTo(0 + size, 0);
								
					
					if(hasText)
					{
						textFormat = new TextFormat();
						textFormat.font = "verdana";
						textFormat.color = 0x000000;
						textFormat.bold = "bold";
						textFormat.size = 11;
						textFieldName = new TextField();
						textFieldName.text = '      '+text;
						textFieldName.width = width;
						textFieldName.height = height;
						
						textFieldName.alpha = 1;
						textFieldName.setTextFormat(textFormat,-1,-1);
						labelSprite.addChild(textFieldName);
					}
				}
				else
				{
					labelSprite.x = x;
					labelSprite.y = y;
					
					labelSprite.graphics.clear();
					labelSprite.graphics.beginFill(Constants.COLOR_TASK_NORMAL_COMPLETED_FONT, .4);
					labelSprite.graphics.drawRoundRectComplex(0,0,width,height,3,3,3,3);
	
					if(hasText)
					{
						textFormat = new TextFormat();
						textFormat.font = "verdana";
						textFormat.color = 0xFFFFFF;
						textFormat.bold = "bold";
						textFormat.size = 11;
						textFieldName = new TextField();
						textFieldName.text = text;
						textFieldName.width = width;
						textFieldName.height = height;
						
						textFieldName.alpha = 1;
						textFieldName.setTextFormat(textFormat,-1,-1);
						labelSprite.addChild(textFieldName);
					}
				}
				if(Sprite(bars.getChildByName(name)) == null)
				{
					bars.addChild(labelSprite);
   	   			}
			/*}
			else
			{
				labelSprite.y = y;
				if(task.duration != 0)
				{
					labelSprite.width = width;
				}else{
					x = x + (scale / 2) - (hypotenuse / 2);
				}
				labelSprite.x = x;
			}*/
   	   }
   	   /*
		* Borra el Sprite object de la tarea seleccionada
		*/
   	   private function removeSpriteBar(task : Task) : void
   	   {
   	   		var name : String = 'name'+task.id;
			if(bars.getChildByName(name) != null)
			{
				bars.removeChild(Sprite(bars.getChildByName(name)));
			}
   	   }
   	   public function outCanvasDataGrid(cursorHandUp : Boolean = true): void
   	   {
   	   	
   	   		if(taskClicked!=null)
   	   		{
   	   	
   	   			removeSpriteBar(taskClicked);
   	   			taskClicked=null;
   	   		}
   	   		taskIdClicked='';
   	   		isDraging=false;
   	   		if(cursorHandUp)
   	   		{
   	   			setCursor('cursorHandUp');
   	   		}
   	   }
   	  
   	   
   	   /*
		* Asigna o delimina dependencias 
		*/
		
       private function clickHandler(event : MouseEvent) : void
   	   {	
   	   		if(taskClicked != null)
   	   		{
   	   			var name : String = 'name'+taskClicked.id;
				if(bars.getChildByName(name) != null)
				{
	   	   			
					var taskIdParent : String = event.target.name;
					var taskOptionOne : Task = Components.instance.tasks.getTask(taskIdParent);
					var taskOptionTwo : Task = Components.instance.tasks.getTask(taskIdParent.substring(4,taskIdParent.length));
					
					var indexTask : int = Math.round((Sprite(bars.getChildByName(name)).y) / UI.ROW_HEIGHT);
					
					removeSpriteBar(taskClicked);
					if(taskClicked.positionVisible - 1 != indexTask)
					{
						if(Components.instance.tasks.allTasks.length - 1 >= indexTask)
						{
							var parentTask : Task = Task(Components.instance.tasks.allTasks.getItemAt(indexTask));
							if(mouseIsOverTask(parentTask, event, 'x'))
							{
								var dependency : Dependency = null;
								if(!taskClicked.isParent(parentTask))
								{
									if(Components.instance.dependencies.validateDependency(parentTask, taskClicked))
									{
										//se crea una dependencia
										dependency = new Dependency(parentTask, 2, 0, 1);
										Components.instance.controller.addDependency(dependency, taskClicked);
										for(var i : int = 0 ; i<Components.instance.tasks.allTasks.length; i++)
										{
											var t : Task = Task(Components.instance.tasks.allTasks.getItemAt(i));
										}
										parentApplication.mainView.filter();
										this.parentApplication.mainView.barChart.selectTask(taskClicked.id);
									}
								}
								else
								{
									//se borra una dependencia
									dependency = Components.instance.dependencies.getDependency(parentTask, taskClicked);
									Components.instance.controller.deleteDependency(dependency,Components.instance.tasks.selectedTask);
								}
							}
						}
					}
					else
					{
						var parentTask : Task = Task(Components.instance.tasks.allTasks.getItemAt(indexTask));
						if(taskClicked.id == parentTask.id || name == taskIdParent || taskClicked.id == taskIdParent || (taskOptionOne==null && taskOptionTwo==null))
						{
							parentDocument.visibilityLoadingProgress(true);
							Components.instance.controller.updateTask(taskClicked);
				   	   		Components.instance.tasks.setParent();
				   	   		
				   	   		var taskVisible : Task = parentDocument.taskList.getVisibleTask(taskClicked.id);
				   	   		var taskTemp : Task = UiTask(taskClicked).clone();
				   	   		taskTemp.positionVisible = taskVisible.positionVisible;
				   	   		
				   	   		Components.instance.tasks.refreshDates();
				   	   		
				   	   		paintSelect(taskTemp);
				   	   						   	   		
				   	   		taskTemp.lastModified = User(Components.instance.users.getUser(Components.instance.session.user.id));
				   	   	//	parentDocument.editTaskPanel.selectedTask = taskTemp;
						}
					}
					dispatchEvent(new Event(Constants.TASKS_FILTERS));
					//dispatchEvent(new Event(Constants.TASK_SELECT));
					//dispatchEvent(new Event(Constants.TASK_CENTER));
			 	}
			 	setCursorUpActual();
   	   		}
   	   		else
   	   		{
   	   			moveHandler(event);
   	   			setCursor('cursorHandUp');
   	   		}
   	   }
   	   /*
		* Inicializa drag and drop
		*/
   	   private function mouseMoveHandler(event : MouseEvent) : void
   	   {
   	   		isMouseDown = true;
	   	  	//se calcula si la posicion del raton esta posionada sobre la tarea seleccionada, en el caso de que no lo este
	   	  	//se inicializa (taskIdClicked='') la variable que reprecenta la tarea seleccionada
	   	   	var task : Task = Components.instance.tasks.getTask(taskIdClicked);
			if(task != null)
			{
				//si el raton NO esta sobre la tarea
				if(!mouseIsOverTask(task, event))
				{
					
					taskIdClicked = '';
					setCursor('cursorHandDown');
				}
				else
				{
					setCursorDownActual();
				}
			}
			else
			{
				setCursor('cursorHandDown');
			}
			var dragInitiator : Canvas = Canvas(event.currentTarget.parent);
			var dragSource : DragSource = new DragSource();
			dragSource.addData(event.currentTarget.parent,  'canvas');
			xOffsetDrag = event.currentTarget.mouseX;
			yOffsetDrag = event.currentTarget.mouseY;
			var canvas : Canvas = new Canvas();
			canvas.visible = false;
			DragManager.doDrag(dragInitiator, dragSource, event, canvas, -15, -15, 1.00);
       } 
       private var startd : Date = new Date();
       public function tms() : void
       {
       	//trace((new Date().getTime()-startd.getTime()));
       	startd.setTime(new Date().getTime());
       }
       /*
		* Inicializa drag and drop
		*/
       private function doDragEnter(event : DragEvent) : void
   	   {
   	   		//if(event.delta > 5){ // This is to set a real drag if the user move the mouse 5 pix
   	   			if(isMouseDown)//esto es para no agarrar el draging que viene del overviewpanecuando(solo funciona el dragind de las barras del gantt, si se hizo mousedown sobre ese canvas)
	   	   		{
	   	   			
	         		DragManager.acceptDragDrop(Canvas(event.target));
	         		isDraging = true;
	         		if(taskIdClicked=='')
	         		{
	         			hideObjectDraging();
	         		} 
	       		}
   	   		//}
   	   }
   	   /*
		* Evento drag
		*/
   	   private function doDragOver(event : DragEvent) : void
       {
       //	   var dateStart2 : Date = new Date();
       	
       		if(taskIdClicked == '')//si no hay tarea seleccionada se mueve el canvas con tpdas las tareas
       		{
			   	//if(moveY != 0)//si es multiplo de UI.ROW_HEIGHT
			   	//{
			   		moveBarChartVerticallyAndHorizontally(event.currentTarget.mouseY - yOffsetDrag, event.currentTarget.mouseX - xOffsetDrag);
			   	//}
		//	   	moveBarChartHorizontally(event.currentTarget.mouseX - xOffsetDrag);
		//	   	var moveY : int = (event.currentTarget.mouseY - yOffsetDrag);
		//	   	if(moveY != 0)//si es multiplo de UI.ROW_HEIGHT
		//	   	{
		//	   		moveBarChartVertically(moveY);
		//	   	}
			   	parentDocument.barChartOverview.setMaskProperties();
       		}
       		else//se mueve la tarea seleccionada
       		{
       			moveHandler(event);
       		}
   	   }
   	   public function moveBarChartVerticallyAndHorizontally(moveY, moveX) : void
   	   {
   	   	  var finalX : int = datesCanvas.x;
   	   	  var finalY : int = barChartCanvas.y;
   	   	  var x : int = datesCanvas.x + moveX;
	   	  if(-x < lastTaskX())
	   	  {	
			  if (x <= 0)
			  {	
				finalX = x;
			  }
			  else
			  {
				finalX = 0;
			  }
		  }
		  if(moveY != 0)
		  {
			  if(parentDocument.taskList.visibleTasks!=null)
		   	  {
		   	  	  var y : int = barChartCanvas.y + moveY;
				  if (y < 0)
				  {
				  	  var maxY : int = ((parentDocument.taskList.visibleTasks.length + 2) * UI.ROW_HEIGHT) - mainCanvas.height;
				  	  if(-y > maxY)
				   	  {
				   	  	if(-maxY < 0)
				   	  	{
				   	  		finalY = - maxY;
				   	  	}
				   	  	else
				   	  	{
				   	  		finalY = 0;
				   	  	}
				   	  }
				   	  else
				   	  {
						finalY = y;
				   	  }
				  }
				  else
				  {
					finalY = 0;
					//parentDocument.taskList.moveGrid(bars.rowHeight, 0);
				  }
		   	  }
		  }
		  datesCanvas.x = finalX;
		  barChartCanvas.x = finalX;
		  barChartCanvas.y = finalY;
		  // trace('This is the new barchart Canvas y:'+finalY+' And this is the new barchart canvas X:'+finalX);
   	   }
	   public function showObjectDraging(moveOverview : Boolean = false):void
	   {
	   	    dateStart = new Date();
	   	    if(isDraging || moveOverview)
	   	    {
		 		parentDocument.visibilityLoadingProgress(true)
			 	canvLines.visible=true;
			 	moveArrows();
			 	leftArrow.visible=true;
				rightArrow.visible=true;
				upArrow.visible=true;
				downArrow.visible=true;
				updateDates(false);
				timerScrollStart();
				//parentDocument.taskList.moveGrid(bars.rowHeight, - barChartCanvas.y);
	   	    }
	   }
   	   public function hideObjectDraging():void
	   {
		 	canvLines.visible=true;
		 	leftArrow.visible=false;
			rightArrow.visible=false;
			upArrow.visible=false;
			downArrow.visible=false;
	   }	   
   	   /*
		* Detiene el timer
		*/
   	   private function stopTimer():void
       {
       	if(timer!=null)
       	{
    	 timer.stop();
       	}
       }
       /*
		* Inicializa el timer
		*/
   	   private function startTimer(direction : String = '') : void 
       {
    	 this.direction = direction;
         // creates a new five-second Timer
        timer = new Timer(10, 1);
        
        // designates listeners for the interval and completion events
        timer.addEventListener(TimerEvent.TIMER, moveBarChartTimer);
        timer.addEventListener(TimerEvent.TIMER_COMPLETE, moveTimerContinue);
        
        // starts the timer ticking
        timer.start();
       }
       /*
		* Llamada mientras el timer esta corriendo
		*/
       private function moveBarChartTimer(event : TimerEvent):void 
       {
        	moveBarChart(direction);
        	//esto se hace para evitar el conflicto del drag and drop sobre el panel
        	xOffsetDrag = mouseX - barChartCanvas.x;
   			yOffsetDrag = mouseY - barChartCanvas.y;
       }
       /*
		* Mueve el gantt horizontalmente de a UI.ROW_HEIGHT pixeles
		*/
       private function moveBarChart(direction : String) : void
       {
       		switch(direction)
	        {
	        	case Constants.LEFT:
	        		moveBarChartHorizontally(UI.ROW_HEIGHT);
	        		break;
	    		case Constants.RIGHT:
	        		moveBarChartHorizontally(-UI.ROW_HEIGHT);
	        		break;
	        	case Constants.UP:
	        		moveBarChartVertically(UI.ROW_HEIGHT);
	        		break;
	        	case Constants.DOWN:
	        		moveBarChartVertically(-UI.ROW_HEIGHT);
	        		break;
	        }
	        parentDocument.barChartOverview.setMaskProperties();
	        moveArrows();
       } 
       /*
		* Llamada mientras el debe detenerse
		*/
       private function moveTimerContinue(event : TimerEvent):void
       {
    	timer.stop();
    	var x : int = 0;
    	var y : int = 0;
    	switch(direction)
        {
        	case Constants.LEFT:
        		x = leftArrow.x + barChartCanvas.x;
        		y = leftArrow.y + barChartCanvas.y;
        		break;
    		case Constants.RIGHT:
        		x = rightArrow.x + barChartCanvas.x;
        		y = rightArrow.y + barChartCanvas.y;
        		break;
        	case 'up':
        		x = upArrow.x + barChartCanvas.x;
        		y = upArrow.y + barChartCanvas.y;
        		break;
        	case 'down':
        		x = downArrow.x + barChartCanvas.x;
        		y = downArrow.y + barChartCanvas.y;
        		break;
        }
        y += 20;
        if(isBetween(mouseX, x, x + 20) && isBetween(mouseY, y, y + 20))
    	{
    		startTimer(direction);
    	}
       }
       /*
		* Retorna true si unnumero esta entre otros dos numeros
		*/
       private function isBetween(value : int, start : int, end : int) : Boolean
       {
    	return ( (value >= start) && (value <= end) );
       }
    /*
	* Cambia el zoom (day, week, month, year)
	*/
    public function changeZoom(zoom : int) : void 
    {       	
    	this.zoom = zoom;
    	var startDaysBefore : Number = (datesCanvas.x / UI.scale);//calcula la primer fecha que se ve en pantallaantes de calcular la nueva escala
    	
    	UI.scale = (parentApplication.width - 30) / zoom;
    	
    	if(-(startDaysBefore * UI.scale) < lastTaskX())
	    {
	    	moveBarChartHorizontally((startDaysBefore * UI.scale)-datesCanvas.x);
	    }
	    else
	    {	
	    	moveBarChartHorizontally((-lastTaskX()-datesCanvas.x)+1);
    	}
    	parentDocument.barChartOverview.setMaskProperties();
    	if(zoom != 30 && zoom != 365)
    	{
    	 	labelVisibleMonth.visible = true;
    	}
    	else
    	{
    	 	labelVisibleMonth.visible = false;
    	}
    	//refreshRedrawed();
	 	updateDates(false);
		refreshGrid();
		
		drawBorderSelected(Components.instance.tasks.selectedTask);
		
		resizeBarChart();
    }
    public function refreshGrid() : void
    {
    	//tasks.refresh();
    	parentDocument.taskList.visibleTasks.refresh();
    }
    
    private var startDateViewLabel : int = -1;
	private var endDateViewLabel : int = -1;
	

	/*
	* Actualiza las fechas para redibujar el calendario horizontal segun le rango de fchas 
	*/
    public function updateDates(isFirst : Boolean) : void
    {
    	if(taskIdClicked == '')
    	{
	    	if(isFirst)//si es la primera vez q se carga todo
	    	{
		    	var ganttState : GanttState = Components.instance.ganttState;
		    	if(ganttState != null)
		    	{
		    		UI.scale = (this.parentApplication.width - 30) / ganttState.scale;
		    		switch (ganttState.scale)
		    		{
		    			case 1:
		    				parentDocument.toggleButtons('day');
		    				break;
		    			case 7:
		    				parentDocument.toggleButtons('week');
		    				break;
		    			case 30:
		    				parentDocument.toggleButtons('month');
		    				break;
		    			case 365:
		    				parentDocument.toggleButtons('year');
		    				break;
		    			
		    		}
		    		if(Components.instance.calendar.toDay(ganttState.startDate) > 0)
		    		{
		    			moveBarChartHorizontally(-(Components.instance.calendar.toDay(ganttState.startDate) * UI.scale))
		    			
		    		}
		    		if(ganttState.y > 0)
		    		{
		    			moveBarChartVertically(-(ganttState.y * UI.ROW_HEIGHT));
		    		}
		    		parentDocument.barChartOverview.setMaskProperties();
		    	}
		    }
			var reserveSpace : int = 600 / UI.scale;
	    	var startDateView : int = -(datesCanvas.x) / UI.scale - reserveSpace;
	    	var endDateView : int = (-(datesCanvas.x) + parentApplication.width) / UI.scale + reserveSpace;
	    	if(startDateView < 0) 
	    	{
	    		startDateView = 0;
	    	}
	    	
	    	//para que cuando se cree la primer barra, esta no comienze muy a la izquierda 
	    	if(Components.instance.tasks.allTasks.length == 0)
	    	{
	    		TaskDate.startDate = Components.instance.calendar.add(TaskDate.startDate, -20);
	    		TaskDate.startDate.setHours(0);
	    		TaskDate.startDate.setMinutes(0);
	    		TaskDate.startDate.setSeconds(0);
	    	}
	    	
	    	switch(zoom)
	    	{
	    		case 30:
	    			calendarScale = 1;
	    			isLabelVisible = true;
	    			dayFormatter.formatString="EEE";
	    			dateFormatter.formatString="DD";
	    			break;
	    		case 365:
	    			calendarScale = 30;
	    			isLabelVisible = true;
	    			dayFormatter.formatString="YYYY";
	    			dateFormatter.formatString="MMMM";
	    			break;
	    		default:
	    			calendarScale = 1;
	    			isLabelVisible = true;
	    			dayFormatter.formatString="EEEE";
	    			dateFormatter.formatString="MM/DD/YYYY";
	    			break;
	    	}
	    	
	    	clearAllChildOfScale();
	    	clearChildrenLabelMonth();//borra todos los labelsMonth
	    	clearChildrenVerticalLinesScale();//borra todos los labelsMonth
	    	var tempDates : ArrayCollection = new ArrayCollection();
			for(var i : int = startDateView; i < endDateView; i+=calendarScale)
			{
				var tempDate : Date = Components.instance.calendar.add(TaskDate.startDate, i)
				if(tempDate.hours != 00)
				{
					tempDate = new Date(tempDate.getFullYear(),tempDate.getMonth(),tempDate.getDate());
				}
				tempDates.addItem(tempDate);
				//if(!findDateInScale(tempDate))
				//{
				//	rangeDatesAll.addItem(tempDate);
				//}
				if(tempDate.getDate()==1)
				{
					createLabelMonth(tempDate, (Components.instance.calendar.toDay(tempDate) * UI.scale) + 10);
				}
				addLabelScale(tempDate);
				addVerticalLineScale(tempDate);
				
			}
			
			var hasShowDivisionMonths : Boolean = false;
			var startScreenX : int = (parentDocument.dragPanelTasks.width - barChartCanvas.x) / UI.scale;
			var endScreenX : int = (parentApplication.width - parentDocument.editPanel.width - barChartCanvas.x) / UI.scale;
			for(i = startScreenX; i < endScreenX; i++)
			{
				if(Components.instance.calendar.add(TaskDate.startDate, i).getDate()==1)
				{
					hasShowDivisionMonths = true;
				}
			}
			if(hasShowDivisionMonths)//si se esta mostrando la division de dos meses
			{
				labelVisibleMonth.visible = false;
			}
			else
			{
				labelVisibleMonth.visible = true;
			}
			//label con el mes que se esta viendo en pantalla
			labelVisibleMonth.text = dateFormatterMonth.format(Components.instance.calendar.add(TaskDate.startDate, Number((-(datesCanvas.x) / UI.scale))));
			
			
			parentDocument.barChartOverview.setMaskProperties();
			rangeDates.list = tempDates;
    	}
    	
    }
    /*
	* Limpia los Sprite object de la escala de fechas
	*/
    private function clearAllChildOfScale() : void
    {
    	for(var i : int = 0 ; i<canvasDatesContent.numChildren; i++)
    	{
    		if(canvasDatesContent.getChildAt(i).name.toString().substr(0,6)=='scale_')
			{
				Sprite(canvasDatesContent.getChildAt(i)).y = -500;
			}
    	}
    }
    /*
	* Crea un Sprite object equivalente a un label en la escala de la fechas
	*/
    private function addLabelScale(date : Date) : void
    {
    	var name : String = 'scale_'+date.getTime()+'_'+this.zoom;
    	var sprite : Sprite = Sprite(canvasDatesContent.getChildByName(name));
		if(sprite == null)
		{
			sprite = new Sprite();
			sprite.name=name;
			//backgroundImage="@Embed(source='imgs/pan_down_arrow.png')"
		}
		sprite.y = 0;
		sprite.x = leftScale(date);
		if(Sprite(canvasDatesContent.getChildByName(name)) == null)
		{
	    	var width : Number = widthScale();
	    	var color : String = getOpaqueBackground(date);
	
			var textFormat : TextFormat = new TextFormat();
			textFormat.font = "verdana";
			textFormat.size = 11;
			textFormat.align = 'center';
	    	
	    	if(calendarScale == 1)
		   	{ 
			  if(date.getDay() == 0 || date.getDay() == 6)//si es sabado y domingo
			  {
			  	textFormat.bold = "bold";
			  }
		   	}
	   	
	   		
	   	
	   		var text2 : TextField = new TextField();
	   		
	    	text2.width=width;
	    	text2.y=12;
	    	
	    	//text2.borderColor = 0xeaeaea;
	    	//text2.border = "solid";
			//text2.opaqueBackground=color;	0xEAEAEAW			
			text2.text=dateFormatter.format(date);
		   	text2.setTextFormat(textFormat,-1,-1);
		   	sprite.addChild(text2);
		   	
		 	if(isLabelVisible)
			{
				var text : TextField = new TextField();
	    		text.width=width;
	    		text.y=-2;
				//text.opaqueBackground=color;
				text.text=dayFormatter.format(date);
				text.setTextFormat(textFormat,-1,-1);
				sprite.addChild(text);
			}
		
			/*
			var img : Image = new Image();
			img.source = linScale;
			img.width=1;
			img.height=30;
			img.y=0;
			sprite.addChild(img);
			*/			
		
			canvasDatesContent.addChild(sprite);
		}
    }
    
    /**
    * Draw the lines of the gantt
    *
    */
    
    
    private function addVerticalLineScale(date : Date) : void
    {
    	var today : Date = new Date();
		var scale : Number = getScale();
    	var name : String = 'scaleLine_'+date.getTime()+'_'+this.zoom;
    	var sprite : Sprite = Sprite(canvLines.getChildByName(name));
    	//trace('this is the date given :'+date+'this is the date of today:'+today);
		if(sprite == null)
		{
			sprite = new Sprite();
			sprite.name=name;
		}
		sprite.y = 0;
		sprite.x=leftScale(date);
		if(Sprite(canvLines.getChildByName(name)) == null)
		{
	    	var top : int = 0;//-3000;
	    	var bottom : int = 6000;
	    	/*if(parentDocument.taskList.visibleTask!=null)
	    	{
	    		bottom = parentDocument.taskList.visibleTask.length * UI.ROW_HEIGHT;//3000;// - (Components.instance.calendar.toDay(date) * UI.ROW_HEIGHT);
	    	}*/
			
			if(Components.instance.calendar.isWeekend(date) && this.zoom != 365)
			{
				if(Components.instance.calendar.isFirstDayOfTheMonth(date))
				{
					sprite.graphics.lineStyle(1, 0x333333, 1);
				}
				else
				{
					sprite.graphics.lineStyle(1, 0xC0C0Bf, 1);
				}
				sprite.graphics.beginFill(0xF3F3EC, 1);
				
				sprite.graphics.moveTo(x, top);
				sprite.graphics.lineTo(x, top);
				sprite.graphics.lineTo(x, bottom);
				sprite.graphics.lineTo(x + scale, bottom);
				sprite.graphics.lineTo(x + scale, top);
				sprite.graphics.lineTo(x, top);
			}
			else if(equals(today, date) && this.zoom != 365)// || equals(tomorrow, date))
			{
				
				if(Components.instance.calendar.isFirstDayOfTheMonth(date))
				{
					sprite.graphics.lineStyle(1, 0x333333, 1);
				}
				else
				{
					sprite.graphics.lineStyle(1, 0x999999, 1);
				}
				sprite.graphics.beginFill(0xC0C0Bf, 1);

				sprite.graphics.moveTo(x, top);
				sprite.graphics.lineTo(x, top);
				sprite.graphics.lineTo(x, bottom);
				sprite.graphics.lineTo(x + scale, bottom);
				sprite.graphics.lineTo(x + scale, top);
				sprite.graphics.lineTo(x, top);
			}
			else
			{
				if(Components.instance.calendar.isFirstDayOfTheMonth(date))
				{
					sprite.graphics.lineStyle(1, 0x333333, 1);
				}
				else
				{
					sprite.graphics.lineStyle(1, 0xC0C0Bf, 1);
				}
				sprite.graphics.moveTo(x, top);
				sprite.graphics.lineTo(x, top);
				sprite.graphics.lineTo(x, bottom);
			}
			canvLines.addChild(sprite);
		}
    }
    
    private function equals(dateOne : Date, dateTwo : Date): Boolean
	{
		return (dateOne.getDate() == dateTwo.getDate() && dateOne.getMonth() == dateTwo.getMonth() && dateOne.getFullYear() == dateTwo.getFullYear());
	}
    
    //rangeDatesAll
    /*private function findDateInScale(date : Date) : Boolean
    {
    	var d : Date = new Date();
    	for(var i : int = 0; i<rangeDatesAll.length; i++)
    	{
    		d.setTime(rangeDatesAll.getItemAt(i));
    		if(date==d)
    		{
    			return true;
    		}
    	}
    	return false;
    }*/
    /*private function indexDateInScale(date : Date) : int
    {
    	var indexTemp : int = -1;
    	for(var i : int = 0; i<rangeDates.length; i++)
    	{
    		if(date.getTime()<Date(rangeDates.getItemAt(i)).getTime())
    		{
    			indexTemp = i;
    		}
    		if(date.getTime()==Date(rangeDates.getItemAt(i)).getTime())
    		{
    			indexTemp = i;
    		}
    	}
    	return indexTemp;
    }*/
    /*
	* Borra el borde que se dibuja en el gantt y que pertenece a la tarea seleccionada
	*/
    public function clesrBorderSelected() : void
    {
      	var name : String = 'border';
		if(bars.getChildByName(name) != null)
		{
			Sprite(bars.getChildByName(name)).graphics.clear();
		}
    }
    /*
	* Dibuja el borde de la tarea seleccionada en el gantt
	*/
    public function drawBorderSelected(task : Task) : void 
    {
    	if(task!=null)
    	{
    		//se dibuja la tarea para ir mostrandolo a medida que se mueve el raton
	      	var scale : Number = getScale();
	  		var width : Number = (task.duration * scale);
			var height : Number = UI.ROW_HEIGHT - 8;
			var x : int = ((task.startDate.toDay() * scale)) + UI.MARGIN;
			var y : int = (task.positionVisible - 1) * UI.ROW_HEIGHT + 4;
			var name : String = 'border';//+task.id;
			var labelSprite : Sprite = null;
			if(bars.getChildByName(name) == null)
			{
				labelSprite = new Sprite();
			}
			else
			{
				labelSprite = Sprite(bars.getChildByName(name));
			}
			
			labelSprite.name = name;
			labelSprite.graphics.clear();
			
			if(width<60000)
			{
			if(task.isMilestone)
			{	
				//
				// If is a milestone.
				// 
				var size : int = 14;
				var hypotenuse : Number = size * 2;	
				x = x + (scale / 2) - (hypotenuse / 2) + 2;
				y = y - 1;
				/*
				labelSprite.graphics.lineStyle(2, Constants.COLOR_TASK_MILESTONE_BORDER, 1);
				labelSprite.graphics.moveTo(x + size, y);
				labelSprite.graphics.lineTo(x + size, y);
				labelSprite.graphics.lineTo(x, y + size);
				labelSprite.graphics.lineTo(x + size, y + (size * 2));
				labelSprite.graphics.lineTo(x + (size * 2), y + size);
				labelSprite.graphics.lineTo(x + size, y);
				*/
				
				labelSprite.graphics.beginFill(0xCFECF2);
				labelSprite.graphics.lineStyle(2, Constants.COLOR_TASK_PARENT_BORDER, 1);
				labelSprite.graphics.moveTo(0, y - 3 );
				labelSprite.graphics.lineTo(0, y - 3);
				labelSprite.graphics.lineTo(0, y + hypotenuse);
				labelSprite.graphics.lineTo(6000, y + hypotenuse);
				labelSprite.graphics.lineTo(6000, y - 3 );
				labelSprite.graphics.lineTo(0, y - 3);	
				
			}
			else if(!UiTask(task).isEditable())
			{
				//
				// If is a task
				// 
				var heightReduce : int = 4;
				var cut : int = 5;
				var triangle : int = 19;
				
				height -= heightReduce;
				
				labelSprite.graphics.beginFill(0xCFECF2);
				labelSprite.graphics.lineStyle(2, Constants.COLOR_TASK_PARENT_BORDER, 1);
				labelSprite.graphics.moveTo(0, y - 3);
				labelSprite.graphics.lineTo(0, y - 3);
				labelSprite.graphics.lineTo(0, y + triangle + 7);
				labelSprite.graphics.lineTo(6000, y + triangle + 7);
				labelSprite.graphics.lineTo(6000, y - 3);
				labelSprite.graphics.lineTo(0, y - 3);	
				
				
				/*
				labelSprite.graphics.moveTo(x - triangle, y);
				labelSprite.graphics.lineTo(x - triangle, y);
				labelSprite.graphics.lineTo(x, y + triangle + 5);
				
				if((x + 5)<(width + x - 5)){
					labelSprite.graphics.lineTo(x + 5, y + triangle - 1);
					labelSprite.graphics.lineTo(width + x - 5, y + triangle - 1);
				}
				
				labelSprite.graphics.lineTo(width + x, y + triangle + 5);
				labelSprite.graphics.lineTo(width + x + triangle, y);
				labelSprite.graphics.lineTo(x - triangle, y);
				*/
				//labelSprite.graphics.lineTo(x + triangle, y);
				//labelSprite.graphics.lineTo(x, y + triangle + 5);
				
				//labelSprite.graphics.moveTo(width+x-triangle,y);
				//labelSprite.graphics.lineTo(width+x-triangle,y);
				//labelSprite.graphics.lineTo(width+x+triangle,y);
				//labelSprite.graphics.lineTo(width+x,y+triangle+5);
			}
			else
			{
				//dibuja cuadrado con las lineas
				/*if(width>=66000)
				{	//para que no se vean gordas
					labelSprite.graphics.lineStyle(1, Constants.COLOR_TASK_NORMAL_BORDER, .5);
				}
				else if(width>=46000)
				{	//para que no se vean gordas
					labelSprite.graphics.lineStyle(0.5, Constants.COLOR_TASK_NORMAL_BORDER, .5);
				}
				else
				{
					labelSprite.graphics.lineStyle(2, Constants.COLOR_TASK_NORMAL_BORDER, .5);
				}*/
				
				labelSprite.graphics.beginFill(0xCFECF2);
				labelSprite.graphics.lineStyle(2, Constants.COLOR_TASK_NORMAL_BORDER);
				labelSprite.graphics.drawRoundRect(0, y - 3 , 6000, height + 6, 6, 6);
				
			}
			}
			if(bars.getChildByName(name) == null)
			{
				//bars.addChild(labelSprite);
				bars.addChildAt(labelSprite,0);
			}
    	}
    }
    /*
	* Borra los label que marcan el mes sobre el gantt
	*/
    private function clearChildrenVerticalLinesScale() : void
	{
		var child : int = canvLines.numChildren;
		for (var i : int = 0; i < child; i++)
		{	
			if(canvLines.getChildAt(i).name.substring(0,10)=='scaleLine_')
			{
				canvLines.removeChildAt(i);
				child--; i--;
			}
		}
   	}
    /*
	* Borra los label que marcan el mes sobre el gantt
	*/
    private function clearChildrenLabelMonth() : void
	{
		if(parent != null)
		{
			var child : int = bars.numChildren;
			for (var i : int = 0; i < child; i++)
			{	
				var time : Number = Number(bars.getChildAt(i).name);
				if(time.toString() != 'NaN')
				{
					bars.removeChildAt(i);
					child--; i--;
				}
			}
		}
   	}
   	/*
	* Crea el Sprite object que indican el mes en el gantt
	*/
	private function createLabelMonth(date : Date, x : int) : void
	{
		var widthTextField : int = 70;
		
		//if(bars.getChildByName(date.getTime().toString()))
		//{
		//	bars.removeChild(bars.getChildByName(date.getTime().toString()));
		//}
		var spriteMonth : Sprite = createSpriteMonth(date);
		spriteMonth.addChild(createTextFieldMonth(Components.instance.calendar.add(date,-1), x - widthTextField - 10, widthTextField, 'right'));
		spriteMonth.addChild(createTextFieldMonth(date, x + 10, widthTextField, 'left'));
		
		bars.addChild(spriteMonth);
	}
	/*
	* Formato para los label de los meses
	*/
	private function createTextFormater(align : String) : TextFormat
	{
		var textFormat : TextFormat = new TextFormat();
		textFormat.font = "verdana";
		textFormat.size = 11;
		textFormat.align = align;
		return textFormat;
	}
	private function createSpriteMonth(date : Date) : Sprite
	{
		var sprite : Sprite = new Sprite();
		sprite.name = date.getTime().toString();
		var height : int = parentApplication.mainView.dragPanelTasks.height - 50;
		sprite.y = (height - 20) - (parentApplication.mainView.barChart.barChartCanvas.y);
		return sprite;
	}
	private function createTextFieldMonth(date : Date, x : int, width : int, align : String) : TextField
	{
		var textField : TextField = new TextField();
		var daysFilter : String = daysFilter();
		if(daysFilter == 'week')
		{
			textField.text = dateFormatterMonth.format(date);
		}
		else if(daysFilter == 'month')
		{
			textField.text = dateFormatterMonthShort.format(date) +' `'+ dateFormatterYearShort.format(date);
		}
		textField.name = date.getMonth().toString();
		textField.width = width;
		textField.x = x;
		textField.selectable = false;
		textField.setTextFormat(createTextFormater(align),-1,-1);
		return textField;
	}	
	public function daysFilter() : String
	{
		var daysFilter : String = '';
		var days : int = ((this.parentApplication.width - 30) / UI.scale);
		switch(days)
		{
			case 1:
				daysFilter = 'day';
				break;
			case 7:
				daysFilter = 'week';
				break;
			case 30:
				daysFilter = 'month';
				break;
			case 365:
				daysFilter = 'year';
				break;
		}
		return daysFilter;
	}
	/*
	 * Setea el cursor 
	 */
	private var cursorActual : String = '';
	public function setCursor(cursor : String) : void
	{
		if(cursorActual != cursor)
		{
			//CursorManager.removeCursor(CursorManager.currentCursorID);
			CursorManager.removeAllCursors();
			cursorActual = cursor;
			switch (cursor)
			{
				case 'cursorHandUp':
					CursorManager.setCursor(cursorHandUp,2.0,-8);
					break;			
				case 'cursorHandDown':
					CursorManager.setCursor(cursorHandDown,2.0,-8);
					break;
				case 'cursorLeftUp':
					CursorManager.setCursor(cursorLeftUp,2.0,-8);
					break;
				case 'cursorRightUp':
					CursorManager.setCursor(cursorRightUp,2.0,-8);
					break;
				case 'cursorCenterUp':
					CursorManager.setCursor(cursorCenterUp,2.0,-8);
					break;
			}
		}
	}
	/*
	* Setea el cursor down equivalente al cursor actual, 
	* es decir que si por ejemplo esta la mano como cursor el down seria la mano presionada
	*/
	public function setCursorDownActual() : void
	{
	    //CursorManager.removeCursor(CursorManager.currentCursorID);
	    CursorManager.removeAllCursors();
		switch (cursorActual)
		{
			case 'cursorHandUp':
				CursorManager.setCursor(cursorHandDown,2.0,-8);
				cursorActual = 'cursorHandDown';
				break;
			case 'cursorLeftUp':
				CursorManager.setCursor(cursorLeftDown,2.0,-8);
				cursorActual = 'cursorLeftDown';
				break;
			case 'cursorRightUp':
				CursorManager.setCursor(cursorRightDown,2.0,-8);
				break;
			case 'cursorCenterUp':
				CursorManager.setCursor(cursorCenterDown,2.0,-8);
				cursorActual = 'cursorCenterDown';
				break;
		}
	}
	/*
	* Setea el cursor up equivalente al cursor actual, 
	* es decir que si por ejemplo esta la mano como "cursor down(o presionada)" 
	* el up seria la mano up(o comun)
	*/
	private function setCursorUpActual() : void
	{
	    //CursorManager.removeCursor(CursorManager.currentCursorID);
	    CursorManager.removeAllCursors();
		switch (cursorActual)
		{
			case 'cursorHandDown':
				CursorManager.setCursor(cursorHandUp,2.0,-8);
				cursorActual = 'cursorHandUp';
				break;
			case 'cursorLeftDown':
				CursorManager.setCursor(cursorLeftUp,2.0,-8);
				cursorActual = 'cursorLeftUp';
				break;
			case 'cursorRightDown':
				CursorManager.setCursor(cursorRightUp,2.0,-8);
				cursorActual = 'cursorRightUp';
				break;
			case 'cursorCenterDown':
				CursorManager.setCursor(cursorCenterUp,2.0,-8);
				cursorActual = 'cursorCenterUp';
				break;
		}
	}
	/*
	 * Setea el cursor por defecto
	 */
	public function defaultCursor() : void
	{
		//CursorManager.removeCursor(CursorManager.currentCursorID);
		CursorManager.removeAllCursors();
		cursorActual = '';
	}
	/*
	 * Retorna true si el cursor esta por defecto
	 */
	public function isDefaultCursor() : Boolean
	{
		return (CursorManager.currentCursorID==0);
	}
	
	/*
	 * Si el raton esta por encima de una barra(de un taskBar)
	 */
	 public function mouseIsOverTask(task : Task, event : MouseEvent, axisValidate : String = '') : Boolean
	 {
	 	if(task!=null)
	 	{
	 		//add 1 day for the duration to display task correctly 
			var duration : int = (task.duration + 1);
		 	var scale : Number = getScale();
			var taskWidth : int = (duration * scale);
			var taskX : int = (task.startDate.toDay() * scale) + barChartCanvas.x;
			var taskY : int = (task.positionVisible * UI.ROW_HEIGHT) + 30 + (barChartCanvas.y);
			var taskHeight : int = UI.ROW_HEIGHT;
			
			//agrando (2px para cada lado) para que capture los eventos que estn cerca del bordde
			taskX -= 2;
			taskWidth += 4;
			taskY -= 2;
			taskHeight += 4;
			
			if(axisValidate == '')//valida que coincida en el eje x y en el eje y
			{
				if( ((event.stageX - 10) > taskX) && ((event.stageX - 10) <= (taskX + taskWidth)) && 
						( event.stageY > taskY ) && ( event.stageY < (taskY + taskHeight) ) )
				{
					return true;
				}
			}
			else if(axisValidate == 'y')//valida solo que coincida el eje y, sin importar la posicion x del raton
			{
				if( ( event.stageY > taskY ) && ( event.stageY < (taskY + taskHeight) ) )
				{
					return true;
					
				}
			}
			else if(axisValidate == 'x')//valida solo que coincida el eje x, sin importar la posicion x del raton
			{
				if( ( (event.stageX - 10) > taskX ) && ( (event.stageX - 10) <= (taskX + taskWidth) ) )
				{
					return true;
				}
			}
		}
		return false;
	 }
	 /*public function htmlTextScale(date : Date) : String
	 {
	 	var htmlText : String = '';
	 	if(isLabelVisible)
		{
			htmlText = dayFormatter.format(date);
		}
		htmlText += '<br>'+dateFormatter.format(date);
		if(calendarScale == 1)
	   	{ 
		  //si es sabado y domingo
		  if(date.getDay() == 0 || date.getDay() == 6)
		  {
		  	htmlText = '<b>'+htmlText+'</b>';
		  }
	   	}
	 	return htmlText;
	 }*/
	 
	 private function widthScale() : Number
	 {
	 	return getScale() * calendarScale;
	 }
	 private function leftScale(date : Date) : Number
	 {
	 	//return (((Components.instance.calendar.toDay(date) + startValueReduce(date)) * getScale()));// + UI.MARGIN;
	 	return Components.instance.calendar.toDay(date) * getScale() + 11;
	 }
	
	 
	 
	 private var timerScroll : Timer;
   	 private function timerScrollStart() : void 
     {
        // creates a new five-second Timer
        timerScroll = new Timer(200, 1);
        
        // designates listeners for the interval and completion events
        timerScroll.addEventListener(TimerEvent.TIMER, timerScrollContinue);
        timerScroll.addEventListener(TimerEvent.TIMER_COMPLETE, timerScrollComplete);
        
        // starts the timer ticking
        timerScroll.start();
     }
     private function timerScrollContinue(event : TimerEvent):void 
     {
     	parentDocument.taskList.moveGrid(bars.rowHeight, - barChartCanvas.y);
     }
     private function timerScrollComplete(event : TimerEvent):void 
     {
     	timerScroll.stop();
     }
	 /*
	 * Cuante la cantidad de tareas que estan ocultas da partir de una posicion dada hacia arriba
	 */
	 public function countTaskNotVisible(position : int) : int
	 {
	 	var count : int = 0;
	 	if(position<=Components.instance.tasks.allTasks.length)
	 	{
		 	for(var i : int = 0; i<position; i++)
		 	{
		 		if(!UiTask(Components.instance.tasks.allTasks.getItemAt(i)).isVisible())
		 		{
		 			count ++;
		 		}
		 	}
		}
	 	return count;
	 }
	 
	 public var dateStart : Date = new Date();
	
	
	public function resizeBarChart() : void
	{
		var height : int = parentDocument.taskList.visibleTasksList.length * UI.ROW_HEIGHT + 800;
		var width : int = lastTaskX() + 2000;
		datesCanvas.width		= width;
		canvasDatesContent.width= width;
		canvLines.width			= width;
		bars.width				= width;
		barChartCanvas.width	= width;
		barChartCanvas.height	= height;
	}
	
	
	
	
	]]>
</mx:Script>
<mx:Style source="css/BarChart.css"/>
<mx:DateFormatter id="dateFormatterMonthShort" formatString="MMM"/>
<mx:DateFormatter id="dateFormatterYearShort" formatString="YY"/>
<mx:DateFormatter id="dateFormatterMonth" formatString="MMMM"/>
<mx:DateFormatter id="dayFormatter" formatString="EEEE"/>
<mx:DateFormatter id="dateFormatter" formatString="MM/DD/YYYY"/>
	<mx:Canvas id="barChartDates" height="30" width="100%" 
		horizontalScrollPolicy="off" verticalScrollPolicy="off"
		mouseMove="outCanvasDataGrid()">	
		<mx:Canvas styleName="canvasDates" id="datesCanvas" height="100%" width="50000" 
			horizontalScrollPolicy="off" verticalScrollPolicy="off">   
		 	<mx:HorizontalList id="canvasDatesContent" height="100%" width="100%" 
		 		horizontalScrollPolicy="off" verticalScrollPolicy="off" mouseOver="defaultCursor()">
		 	</mx:HorizontalList>
		</mx:Canvas>
	</mx:Canvas>
	<mx:Canvas id="mainCanvas" height="100%" width="100%" 
		horizontalScrollPolicy="off" verticalScrollPolicy="off">
		<mx:Canvas styleName="canvasDataGrids" id="barChartCanvas" y="0" height="10000" width="50000" 
			horizontalScrollPolicy="off" verticalScrollPolicy="off"
			creationComplete = "panelHandler(event);"
			dragEnter = "doDragEnter(event);" 
			dragOver="doDragOver(event);"
			dragDrop="showObjectDraging();isDraging=false;setCursor('cursorHandUp');"
			dragExit="showObjectDraging();">
				<mx:DataGrid styleName="gridDatesLines" id="canvLines" alpha="0.5" selectable="false" rowHeight="30" width="50000" height="0" 
				 x="0" headerHeight="0"  horizontalScrollPolicy="off" verticalScrollPolicy="off">
					<mx:columns>
						<mx:DataGridColumn width="0" />
					</mx:columns>
				</mx:DataGrid>
				<mx:DataGrid selectable="false" styleName="gridTaskRenderer" id="bars" width="50000" 
					horizontalScrollPolicy="off" verticalScrollPolicy="off"
					dataProvider="{parentDocument.taskList.visibleTasks}" rowHeight="30" 
					height="100%" x="0" headerHeight="0"
					 ><!--itemClick="select(event)"-->
					<mx:columns>
						<mx:DataGridColumn  id="columnTaskRenderer" width="0"
							itemRenderer="com.salesforce.gantt.renderers.TaskRenderer"
							/>
						<mx:DataGridColumn      
							itemRenderer="com.salesforce.gantt.renderers.DependencyRenderer"
							/>
					</mx:columns>
				</mx:DataGrid>
				<!-- Scrol Images -->
				<mx:Image id="leftArrow" rotation="270"
					mouseDown="moveBarChart(Constants.LEFT);startTimer(Constants.LEFT)" 
					mouseUp="stopTimer();updateDates(false)" 
				 	 source="@Embed(source='imgs/arrow.png')"/>
				<mx:Image id="rightArrow" rotation="90"
					mouseDown="moveBarChart(Constants.RIGHT);startTimer(Constants.RIGHT)" 
					mouseUp="stopTimer();updateDates(false)"
					 source="@Embed(source='imgs/arrow.png')"/>
				<mx:Image id="upArrow"
					mouseDown="moveBarChart(Constants.UP);startTimer(Constants.UP)" 
					mouseUp="showObjectDraging(true);stopTimer();" 
					source="@Embed(source='imgs/arrow.png')"/>
				<mx:Image id="downArrow" rotation="180"
					mouseDown="moveBarChart(Constants.DOWN);startTimer(Constants.DOWN)"
					mouseUp="showObjectDraging(true);stopTimer();"
					source="@Embed(source='imgs/arrow.png')" />
				<mx:Label id="labelVisibleMonth" visible="false" styleName="labelVisibleMonth" />
		</mx:Canvas>
	</mx:Canvas>
</mx:Panel>